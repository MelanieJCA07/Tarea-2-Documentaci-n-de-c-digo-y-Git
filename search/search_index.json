{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Rk4 Module","text":"<p>Dentro de las ciencias, es fundamental el poder explicar y resolver la trayectoria temporal de alguna cantidad como funci\u00f3n de alg\u00fan generador din\u00e1mico; lo cual se realiza por medio de un modelo din\u00e1mico. A veces, podemos realizar el modelo din\u00e1mico de un estado gen\u00e9rico utilizando la siguiente ecuaci\u00f3n     \\begin{equation}     \\frac{dy}{dt} = f(t, y),     \\end{equation} Que se encontrar\u00eda dependiente a la condici\u00f3n inicial de:     \\begin{equation}     y(t_0) = y_0.     \\end{equation} En este programa, analizaremos el funcionamiento de este modelo din\u00e1mico por medio de un ejemplo. Este programa se encuentra en [github.com]{git@github.com:MelanieJCA07/Tarea-2-Documentaci-n-de-c-digo-y-Git.git} ~                        </p>"},{"location":"explanation/","title":"Explanation","text":"<p>En este programa, utilizaremos el m\u00e9todo Runge-Kutta de orden 4, el cual es un m\u00e9todo iterativo donde cada repetici\u00f3n nos da un punto temporal los cuales se grafican para obtener una soluci\u00f3n, esta estimaci\u00f3n a la soluci\u00f3n a un punto temporal, se realiza de la siguiente forma:</p> <p>$$</p> <pre><code>\\\\begin{aligned}\n    y_n+1  = y_n +  \\\\frac{1}{6}(k_1 +2k_2 +2k_3 +k_4)\n    k_1 = h*f(t_n , y_n ) \\\\\\\\\n    k_2 = h*f(t_n + h/2 , y_n + (k_1)/2)\\\\\\\\\n    k_3 = h*f(t_n + h/2 , y_n + (k_2)/2)\\\\\\\\\n    k_4 = h*f(t_n + h , y_n + k_3)\\\\\\\\\n\\\\end{aligned}\\n\"\n</code></pre> <p>$$</p>"},{"location":"reference/","title":"Reference","text":"<p>Aqu\u00ed se muestran las funciones utilizadas:</p> <p>:::funciones.rk4</p>"},{"location":"rk4/","title":"RK4 Implementation","text":"<p>This document describes the Runge-Kutta 4th order method implemented in Python.</p>"},{"location":"rk4/#code-implementation","title":"Code Implementation","text":"<p>```python import numpy as np import matplotlib.pyplot as plt</p> <p>def dyn_generator(oper, state):     \"\"\" -i[O,y(t)].</p> <pre><code>\"O\" es el operador, i la variable compleja, \"y(t)\" es la funcion dependiente del tiempo.\n\nExamples:\n    oOper operador lineal.\n    yInit estado inicial.\n\n    &gt;&gt;&gt; oOper = np.array([[0, 1], [1, 0]])\n    &gt;&gt;&gt; yInit = np.array([[1, 0], [0, 0]])\n    &gt;&gt;&gt; dyn_generator(oOper, yInit)\n\nArgs:\n    oper (Numpy array): primer argumento (operador).\n    state (Numpy array): Segundo argumento (estado).\n\nReturns:\n    (Numpy array): Nos devuelve el resultado luego de utilizar el operador -i[A.B] = -i(AB - BA).\n\"\"\"\nreturn (np.dot(oper, state) - np.dot(state, oper)) * (-1.0j)\n</code></pre> <p>def rk4(func, oper, state, h):     \"\"\" Runge-Kutta 4, el metodo numerico en el que se basa el c\u00f3digo.</p> <pre><code>Args:\n    func (Function): primer argumento. Es la funcion a la que se le aplica el Rk4 obtenido de la funci\u00f3n anterior.\n    oper (Numpy array): Segundo argumento (operador lineal).\n    state (Numpy array): Tercer argumento. Donde se reflejan las iteraciones, ya que es donde se cambia el estado inicial con el paso del tiempo.\n    h (float): paso temporal.\n\nReturns:\n    (Numpy array): Devuelve el estado del sistema dinamico.\nExamples:\n    &gt;&gt;&gt; oOper = np.array([[0, 1], [1, 0]])\n    &gt;&gt;&gt; yInit = np.array([[1, 0], [0, 0]])\n    &gt;&gt;&gt; times = np.linspace(0, 10, 150)\n    &gt;&gt;&gt; h = times[1] - times[0]\n    &gt;&gt;&gt; print(rk4(dyn_generator, oOper, yInit, h))\n\"\"\"\nk1 = h * func(oper, state)\nk2 = h * func(oper, state + (k1 / 2))\nk3 = h * func(oper, state + (k2 / 2))\nk4 = h * func(oper, state + k3)\nreturn state + (1 / 6) * (k1 + (2 * k2) + (2 * k3) + k4)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Para utiiazr las funciones, mostraremos el siguiente ejemplo:</p> <pre><code>#Establecemos la variable compleja y el operador que se necesita\niConst = 1.0j\noOper = np.array([[0, 1], [1, 0]])\n\n#Definimimos el las condiciones iniciales establecidas por el problema.\nyInit = np.array([[1, 0], [0, 0]])\n\n#Necesitamos crear un arreglo de valores temporales por medio del uso denp.linspace, adem\u00e1s creamos la variable que nos muestra el paso del tiempo.\ntimes=np.linspace(0,10,150)\nh= times[1]-times[0]\n\n#Vamos a establecer los arreglos que van a empezar en 0.\nstateQuant00 = np.zeros(times.size)\nstateQuant11 = np.zeros(times.size)\n\n#En la siguiente funci\u00f3n se muestra la evoluci\u00f3n temporal:\nfor tt in range(times.size):\n\n # Utilizamos el valor de las entradas (0,0) y (1,1). \n stateQuant00[tt] = np.real(yInit[0,0]) \n     stateQuant11[tt] = np.real(yInit[1,1])\n\n# Se utiliza la funci\u00f3n  rk4 operando sobre yInit y obtenemos el resultado.\n yN = rk4(dyn_generator, oOper, yInit, h)\n\n# Asignamos yN a yInit para que el operador se vaya iterando.\n yInit = yN\n</code></pre> <p>Por \u00faltimo, realizamos la graficaci\u00f3n de los puntos obtenidos en cada iteraci\u00f3n, utilizando la herramienta matplot.lib:     #plt.plot(times,stateQuant00) plt.plot(times,stateQuant11)</p> <pre><code>#plt.show()\n</code></pre> <p>En la imagen de abajo, encontramos una representaci\u00f3n del comportamiento del m\u00e9todo de Runge-Kutta.  </p>"}]}