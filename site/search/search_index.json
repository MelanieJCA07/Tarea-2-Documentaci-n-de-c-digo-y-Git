{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Rk4 Module","text":"<p>Dentro de las ciencias, es fundamental el poder explicar y resolver la trayectoria temporal de alguna cantidad como funci\u00f3n de alg\u00fan generador din\u00e1mico; lo cual se realiza por medio de un modelo din\u00e1mico. A veces, podemos realizar el modelo din\u00e1mico de un estado gen\u00e9rico utilizando la siguiente ecuaci\u00f3n     \\begin{equation}     \\frac{dy}{dt} = f(t, y),     \\end{equation} Que se encontrar\u00eda dependiente a la condici\u00f3n inicial de:     \\begin{equation}     y(t_0) = y_0.     \\end{equation} En este programa, analizaremos el funcionamiento de este modelo din\u00e1mico por medio de un ejemplo. Este programa se encuentra en [github.com]{git@github.com:MelanieJCA07/Tarea-2-Documentaci-n-de-c-digo-y-Git.git} ~                        </p>"},{"location":"explanation/","title":"Explanation","text":"<p>En este programa, utilizaremos el m\u00e9todo Runge-Kutta de orden 4, el cual es un m\u00e9todo iterativo donde cada repetici\u00f3n nos da un punto temporal los cuales se grafican para obtener una soluci\u00f3n, esta estimaci\u00f3n a la soluci\u00f3n a un punto temporal, se realiza de la siguiente forma:</p> <p>$$</p> <pre><code>\\\\begin{aligned}\n    y_n+1  = y_n +  \\\\frac{1}{6}(k_1 +2k_2 +2k_3 +k_4)\n    k_1 = h*f(t_n , y_n ) \\\\\\\\\n    k_2 = h*f(t_n + h/2 , y_n + (k_1)/2)\\\\\\\\\n    k_3 = h*f(t_n + h/2 , y_n + (k_2)/2)\\\\\\\\\n    k_4 = h*f(t_n + h , y_n + k_3)\\\\\\\\\n\\\\end{aligned}\\n\"\n</code></pre> <p>$$</p>"},{"location":"reference/","title":"Reference","text":"<p>Aqu\u00ed se muestran las funciones utilizadas:</p> <p>:::funciones.rk4</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Para utiiazr las funciones, mostraremos el siguiente ejemplo:</p> <pre><code>#Establecemos la variable compleja y el operador que se necesita\niConst = 1.0j\noOper = np.array([[0, 1], [1, 0]])\n\n#Definimimos el las condiciones iniciales establecidas por el problema.\nyInit = np.array([[1, 0], [0, 0]])\n\n#Necesitamos crear un arreglo de valores temporales por medio del uso denp.linspace, adem\u00e1s creamos la variable que nos muestra el paso del tiempo.\ntimes=np.linspace(0,10,150)\nh= times[1]-times[0]\n\n#Vamos a establecer los arreglos que van a empezar en 0.\nstateQuant00 = np.zeros(times.size)\nstateQuant11 = np.zeros(times.size)\n\n#En la siguiente funci\u00f3n se muestra la evoluci\u00f3n temporal:\nfor tt in range(times.size):\n\n # Utilizamos el valor de las entradas (0,0) y (1,1). \n stateQuant00[tt] = np.real(yInit[0,0]) \n     stateQuant11[tt] = np.real(yInit[1,1])\n\n# Se utiliza la funci\u00f3n  rk4 operando sobre yInit y obtenemos el resultado.\n yN = rk4(dyn_generator, oOper, yInit, h)\n\n# Asignamos yN a yInit para que el operador se vaya iterando.\n yInit = yN\n</code></pre> <p>Por \u00faltimo, realizamos la graficaci\u00f3n de los puntos obtenidos en cada iteraci\u00f3n, utilizando la herramienta matplot.lib:     #plt.plot(times,stateQuant00) plt.plot(times,stateQuant11)</p> <pre><code>#plt.show()\n</code></pre> <p>En la imagen de abajo, encontramos una representaci\u00f3n del comportamiento del m\u00e9todo de Runge-Kutta.  </p>"}]}